/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.functions.function;

import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.scijava.functions.annotations.Container;

/**
 * Container class for computer-style functional interfaces at various
 * <a href="https://en.wikipedia.org/wiki/Arity">arities</a>.
 * <p>
 * A computer has functional method {@code compute} with a number of arguments
 * corresponding to the arity, plus an additional argument for the preallocated
 * output to be populated by the computation.
 * </p>
 * <p>
 * Each computer interface implements a corresponding {@link Consumer}-style
 * interface (see {@link Consumers}) with arity+1; the consumer's {@code accept}
 * method simply delegates to {@code compute}. This pattern allows computer ops
 * to be used directly as consumers as needed.
 * </p>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class Computers {

	private Computers() {
		// NB: Prevent instantiation of utility class.
	}

#foreach($arity in $arities)
#set($rawClass = "Arity$arity")
#set($genericParams = $generics.call($arity))
#set($gClass = "$rawClass$genericParams")

	@FunctionalInterface
	public interface $gClass extends
		$consumerArity.call($arity)$genericParams
	{

		void compute($computeParams.call($arity));

		@Override
		default void accept($acceptParams.call($arity))
		{
			compute($computeArgs.call($arity));
		}
	}
#end##foreach($arity)
}
