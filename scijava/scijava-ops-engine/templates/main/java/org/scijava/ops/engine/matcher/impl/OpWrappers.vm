/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.ops.engine.matcher.impl;

import java.util.function.BiFunction;
import java.util.function.Function;

import org.scijava.function.Computers;
import org.scijava.function.Container;
import org.scijava.function.Functions;
import org.scijava.function.Inplaces;
import org.scijava.function.Producer;
import org.scijava.ops.api.OpMetadata;
import org.scijava.ops.api.OpWrapper;
import org.scijava.ops.api.RichOp;
import org.scijava.plugin.Plugin;

public class OpWrappers {

	// -- producer --

	@Plugin(type = OpWrapper.class)
	public static class ProducerOpWrapper<T> implements OpWrapper<Producer<T>> {

		@Override
		public RichOp<Producer<T>> wrap(final Producer<T> op, //
			final OpMetadata metadata)
		{
			class GenericTypedProducer //
				extends DefaultRichOp<Producer<T>> //
				implements Producer<T>
			{

				public GenericTypedProducer()
				{
					super(op, metadata);
				}

				@Override
				public T create() {
					preprocess();

					// Call the op
					T out = op.create();

					postprocess(out);

					return out;
				}

			}
			return new GenericTypedProducer();
		}
	}

	// -- functions --

#foreach($arity in [1..$maxArity])
#set($fg = $functionGenerics.call($arity))
	@Plugin(type = OpWrapper.class)
	public static class Function${arity}OpWrapper$generics.call($arity) //
		implements //
		OpWrapper<$fg>
	{

		@Override
		public RichOp<$fg> wrap( //
			final $fg op, //
			final OpMetadata metadata)
		{
			class GenericTypedFunction${arity} //
				extends DefaultRichOp<$fg> //
				implements $fg 
			{

				public GenericTypedFunction${arity}()
				{
					super(op, metadata);
				}

				@Override
				public O apply($applyParams.call($arity)) //
				{
					preprocess($applyArgs.call($arity));

					// Call the op
					O out = op.apply($applyArgs.call($arity));

					postprocess(out);
					return out;
				}

			}
			return new GenericTypedFunction${arity}();
		}
	}

#end
	// -- computers --

#foreach($arity in [0..$maxArity])
#set($cg = $computerGenerics.call($arity))
	@Plugin(type = OpWrapper.class)
	public static class Computer${arity}OpWrapper$generics.call($arity) //
		implements //
		OpWrapper<$cg>
	{

		@Override
		public RichOp<$cg> wrap( //
			final $cg op, //
			final OpMetadata metadata)
		{
			class GenericTypedComputer${arity} //
				extends DefaultRichOp<$cg> //
				implements $cg 
			{
				public GenericTypedComputer${arity}()
				{
					super(op, metadata);
				}

				@Override
				public void compute($computeParams.call($arity)) //
				{
					preprocess($computeArgs.call($arity));

					// Call the op
					op.compute($computeArgs.call($arity));

					postprocess(out);
				}

			}
			return new GenericTypedComputer${arity}();
		}
	}

#end
	// -- inplaces --

#foreach($arity in [1..$maxArity])
#foreach($a in [1..$arity])
#set($ig = $inplaceGenerics.call($arity, $a))
	@Plugin(type = OpWrapper.class)
	public static class Inplace${inplaceSuffix.call($arity, $a)}OpWrapper$inplaceTypeParams.call($arity, $a) //
		implements //
		OpWrapper<$ig> //
	{

		@Override
		public RichOp<$ig> wrap( //
			final $ig op, //
			final OpMetadata metadata)
		{
			class GenericTypedInplace${inplaceSuffix.call($arity, $a)} //
				extends DefaultRichOp<$ig> //
				implements $ig 
			{
				public GenericTypedInplace${inplaceSuffix.call($arity, $a)}()
				{
					super(op, metadata);
				}

				@Override
				public void mutate($mutateParams.call($arity, $a)) //
				{
					preprocess($mutateArgs.call($arity, $a));

					// Call the op
					op.mutate($mutateArgs.call($arity, $a));

					// Log a new execution
					postprocess(ioType);
				}

			}
			return new GenericTypedInplace${inplaceSuffix.call($arity, $a)}();
		}
	}

#end	
#end	


}
