/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.functions.function;

import java.util.function.BiConsumer;
import java.util.function.Consumer;

import org.scijava.functions.annotations.Mutable;

/**
 * Container class for inplace-style functional interfaces at various
 * <a href="https://en.wikipedia.org/wiki/Arity">arities</a>.
 * <p>
 * An inplace has functional method {@code mutate} with a number of arguments
 * corresponding to the arity. Any of the arguments annotated
 * with @{@link Mutable} may be mutated during execution. Some interfaces narrow
 * this behavior to only a specific argument; most ops in practice will
 * implement one of these narrowed interfaces. For example,
 * {@link Inplaces.Arity2_1} is a binary inplace op that mutates the first of
 * two arguments&mdash;e.g., an {@code a /= b} division operation would be an
 * {@link Inplaces.Arity2_1}, whereas {@code b = a / b} would be an
 * {@link Inplaces.Arity2_2}.
 * </p>
 * <p>
 * Each inplace interface implements a corresponding {@link Consumer}-style
 * interface (see {@link Consumers}) with same arity; the consumer's
 * {@code accept} method simply delegates to {@code mutate}. This pattern allows
 * inplace ops to be used directly as consumers as needed.
 * </p>
 * <p>
 * Note that there is no nullary (arity 0) inplace interface, because there
 * would be no arguments to mutate; see also {@link Consumers.Arity0},
 * {@link Computers.Arity0} and {@link Producer}.
 * </p>
 *
 * @author Curtis Rueden
 * @author Gabriel Selzer
 */
public final class Inplaces {

	private Inplaces() {
		// NB: Prevent instantiation of container class.
	}

	@FunctionalInterface
	public interface Arity1<IO> extends Consumer<IO> {

		void mutate(@Mutable IO io);

		@Override
		default void accept(IO io) {
			mutate(io);
		}
	}

#foreach($arity in [2..$maxArity])
#set($cArity = $arity - 1)
	@FunctionalInterface
	public interface Arity${arity}$allMutableGenerics.call($arity) extends ${consumerArity.call($cArity)}$allMutableGenerics.call($arity)
	{

		void mutate($allMutableMutateParams.call($arity));

		@Override
		default void accept($allMutableMutateParams.call($arity))
		{
			mutate($allMutableMutateArgs.call($arity));
		}
	}

#foreach($a in [1..$arity])
	@FunctionalInterface
	public interface $simplifiedInplace.call($arity, $a)$generics.call($arity, $a) extends Arity${arity}$generics.call($arity, $a)
	{

		@Override
		void mutate($mutateArgs.call($arity, $a));
	}

#end
#end
}
