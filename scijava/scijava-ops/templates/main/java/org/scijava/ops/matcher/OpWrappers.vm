/*
 * This is autogenerated source code -- DO NOT EDIT. Instead, edit the
 * corresponding template in templates/ and rerun bin/generate.groovy.
 */

package org.scijava.ops.matcher;

import java.lang.reflect.Type;
import java.util.Arrays;
import java.util.Collections;
import java.util.function.BiFunction;
import java.util.function.Function;

import org.scijava.function.Computers;
import org.scijava.function.Container;
import org.scijava.function.Functions;
import org.scijava.function.Inplaces;
import org.scijava.function.Producer;
import org.scijava.ops.OpInfo;
import org.scijava.ops.provenance.OpExecutionSummary;
import org.scijava.ops.provenance.OpHistory;
import org.scijava.ops.util.OpWrapper;
import org.scijava.plugin.Plugin;
import org.scijava.types.GenericTyped;

public class OpWrappers {

	// -- producer --

	@Plugin(type = OpWrapper.class)
	public static class ProducerOpWrapper<T> implements OpWrapper<Producer<T>> {

		@Override
		public Producer<T> wrap(final Producer<T> op, final OpInfo info, final Type reifiedType) {
			class GenericTypedProducer implements Producer<T>, GenericTyped {

				@Override
				public T create() {
					// Log a new execution
					OpExecutionSummary e = new OpExecutionSummary(info, op);
					OpHistory.addExecution(e);

					// Call the op
					T out = op.create();

					// Record the execution's completion
					e.recordCompletion(out);
					return out;
				}

				@Override
				public Type getType() {
					return reifiedType;
				}
			}
			return new GenericTypedProducer();
		}
	}

	// -- functions --

#foreach($arity in [1..$maxArity])
#set($fg = $functionGenerics.call($arity))
	@Plugin(type = OpWrapper.class)
	public static class Function${arity}OpWrapper$generics.call($arity) //
		implements //
		OpWrapper<$fg>
	{

		@Override
		public $fg wrap( //
			final $fg op, //
			final OpInfo info, //
			final Type reifiedType)
		{
			class GenericTypedFunction${arity} implements //
				$fg, //
				GenericTyped //
			{

				@Override
				public O apply($applyParams.call($arity)) //
				{
					// Log a new execution
					OpExecutionSummary e = new OpExecutionSummary(info, op);
					OpHistory.addExecution(e);

					// Call the op
					O out = op.apply($applyArgs.call($arity));

					// Record the execution's completion
					e.recordCompletion(out);
					return out;
				}

				@Override
				public Type getType() {
					return reifiedType;
				}
			}
			return new GenericTypedFunction${arity}();
		}
	}

#end
	// -- computers --

#foreach($arity in [0..$maxArity])
#set($cg = $computerGenerics.call($arity))
	@Plugin(type = OpWrapper.class)
	public static class Computer${arity}OpWrapper$generics.call($arity) //
		implements //
		OpWrapper<$cg>
	{

		@Override
		public $cg wrap( //
			final $cg op, //
			final OpInfo info, //
			final Type reifiedType)
		{
			class GenericTypedComputer${arity} implements //
				$cg, //
				GenericTyped
			{

				@Override
				public void compute($computeParams.call($arity)) //
				{
					// Log a new execution
					OpExecutionSummary e = new OpExecutionSummary(info, op);
					OpHistory.addExecution(e);

					// Call the op
					op.compute($computeArgs.call($arity));

					// Record the execution's completion
					e.recordCompletion(out);
				}

				@Override
				public Type getType() {
					return reifiedType;
				}
			}
			return new GenericTypedComputer${arity}();
		}
	}

#end
	// -- inplaces --

#foreach($arity in [1..$maxArity])
#foreach($a in [1..$arity])
#set($ig = $inplaceGenerics.call($arity, $a))
	@Plugin(type = OpWrapper.class)
	public static class Inplace${inplaceSuffix.call($arity, $a)}OpWrapper$inplaceTypeParams.call($arity, $a) //
		implements //
		OpWrapper<$ig> //
	{

		@Override
		public $ig wrap( //
			final $ig op, //
			final OpInfo info, //
			final Type reifiedType)
		{
			class GenericTypedInplace${inplaceSuffix.call($arity, $a)} //
				implements $ig, //
				GenericTyped
			{

				@Override
				public void mutate($mutateParams.call($arity, $a)) //
				{
					// Log a new execution
					OpExecutionSummary e = new OpExecutionSummary(info, op);
					OpHistory.addExecution(e);

					// Call the op
					op.mutate($mutateArgs.call($arity, $a));

					// Record the execution's completion
					e.recordCompletion(ioType);
				}

				@Override
				public Type getType() {
					return reifiedType;
				}
			}
			return new GenericTypedInplace${inplaceSuffix.call($arity, $a)}();
		}
	}

#end	
#end	


}
